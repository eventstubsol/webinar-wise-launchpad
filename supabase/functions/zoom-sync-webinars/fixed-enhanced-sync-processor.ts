import { updateSyncLog, updateSyncStage } from './database-operations.ts';\nimport { createZoomAPIClient } from './zoom-api-client.ts';\n\nconsole.log('📦 FIXED ENHANCED sync processor loaded successfully');\n\nexport interface SyncOperation {\n  id: string;\n  connection_id: string;\n  sync_type: string;\n  status: string;\n  options?: {\n    debug?: boolean;\n    testMode?: boolean;\n    forceRegistrantSync?: boolean;\n  };\n}\n\nexport async function processEnhancedWebinarSync(\n  supabase: any,\n  syncOperation: SyncOperation,\n  connection: any,\n  syncLogId: string\n): Promise<void> {\n  console.log(`🚀 Starting FIXED ENHANCED webinar sync for connection: ${connection.id}`);\n  \n  let processedCount = 0;\n  let totalWebinars = 0;\n  const BATCH_SIZE = 5;\n  \n  try {\n    await updateSyncLog(supabase, syncLogId, {\n      sync_status: 'in_progress',\n      started_at: new Date().toISOString()\n    });\n\n    const client = await createZoomAPIClient(connection, supabase);\n    console.log('✅ Zoom API client created successfully');\n    \n    await updateSyncStage(supabase, syncLogId, null, 'fetching_webinars', 10);\n    \n    const webinars = await client.listWebinarsWithRange({\n      type: 'all',\n      page_size: 300\n    });\n    \n    totalWebinars = webinars.length;\n    console.log(`📊 Found ${totalWebinars} webinars to process`);\n    \n    await updateSyncLog(supabase, syncLogId, {\n      total_items: totalWebinars,\n      processed_items: 0\n    });\n    \n    if (totalWebinars === 0) {\n      await updateSyncLog(supabase, syncLogId, {\n        sync_status: 'completed',\n        completed_at: new Date().toISOString(),\n        processed_items: 0,\n        stage_progress_percentage: 100\n      });\n      return;\n    }\n    \n    await updateSyncStage(supabase, syncLogId, null, 'processing_webinars', 20);\n    \n    for (let batchStart = 0; batchStart < webinars.length; batchStart += BATCH_SIZE) {\n      const batchEnd = Math.min(batchStart + BATCH_SIZE, webinars.length);\n      const batch = webinars.slice(batchStart, batchEnd);\n      \n      console.log(`📦 Processing batch ${Math.floor(batchStart / BATCH_SIZE) + 1} (webinars ${batchStart + 1}-${batchEnd})`);\n      \n      for (let i = 0; i < batch.length; i++) {\n        const webinar = batch[i];\n        const overallIndex = batchStart + i;\n        const progressPercentage = 20 + Math.round((overallIndex / totalWebinars) * 70);\n        \n        try {\n          console.log(`🔄 Processing webinar ${overallIndex + 1}/${totalWebinars}: ${webinar.id}`);\n          \n          await updateSyncStage(supabase, syncLogId, webinar.id?.toString(), 'processing_webinar', progressPercentage);\n          \n          const webinarDetails = await client.getWebinar(webinar.id);\n          const wasStored = await storeWebinarFixed(supabase, webinarDetails, connection.id);\n          \n          if (wasStored) {\n            processedCount++;\n            console.log(`✅ Webinar ${webinar.id} stored (${processedCount}/${totalWebinars})`);\n          } else {\n            console.error(`❌ Failed to store webinar ${webinar.id}`);\n          }\n          \n        } catch (error) {\n          console.error(`❌ Error processing webinar ${webinar.id}:`, error.message);\n        }\n      }\n      \n      await updateSyncLog(supabase, syncLogId, {\n        processed_items: processedCount\n      });\n      \n      console.log(`✅ Batch complete: processed ${processedCount}/${totalWebinars} total webinars`);\n    }\n    \n    await updateSyncLog(supabase, syncLogId, {\n      sync_status: 'completed',\n      completed_at: new Date().toISOString(),\n      processed_items: processedCount,\n      stage_progress_percentage: 100\n    });\n    \n    console.log(`🎉 Fixed enhanced sync completed! Processed ${processedCount}/${totalWebinars} webinars`);\n    \n  } catch (error) {\n    console.error(`💥 Fixed enhanced sync failed:`, error);\n    \n    await updateSyncLog(supabase, syncLogId, {\n      sync_status: 'failed',\n      completed_at: new Date().toISOString(),\n      error_message: error.message,\n      processed_items: processedCount\n    });\n    \n    throw error;\n  }\n}\n\n// Helper function for safe field extraction\nfunction getSafeValue<T>(primary: T, fallback: T, defaultValue: T | null = null): T | null {\n  return primary !== undefined && primary !== null ? primary : \n         fallback !== undefined && fallback !== null ? fallback : \n         defaultValue;\n}\n\n// Helper function for safe numeric extraction (handles 0 correctly)\nfunction getSafeNumeric(primary: any, fallback: any): number | null {\n  if (typeof primary === 'number') return primary;\n  if (typeof fallback === 'number') return fallback;\n  return null;\n}\n\n// Helper function for safe string extraction (handles empty strings)\nfunction getSafeString(primary: any, fallback: any, allowEmpty: boolean = false): string | null {\n  if (typeof primary === 'string' && (allowEmpty || primary.length > 0)) return primary;\n  if (typeof fallback === 'string' && (allowEmpty || fallback.length > 0)) return fallback;\n  return null;\n}\n\n// FIXED webinar storage function with proper null-coalescing\nasync function storeWebinarFixed(\n  supabase: any, \n  webinar: any, \n  connectionId: string\n): Promise<boolean> {\n  try {\n    console.log(`🔍 FIXED: Raw webinar data for ${webinar.id}:`, JSON.stringify(webinar, null, 2));\n    \n    const settings = webinar.settings || {};\n    \n    // FIXED: Proper field extraction with null-coalescing\n    const webinarData: any = {\n      // Core identification fields\n      webinar_id: webinar.id?.toString(),\n      webinar_uuid: webinar.uuid,\n      connection_id: connectionId,\n      \n      // Basic webinar information\n      topic: webinar.topic,\n      type: webinar.type,\n      start_time: webinar.start_time,\n      duration: webinar.duration,\n      timezone: webinar.timezone,\n      status: webinar.status,\n      \n      // Host information\n      host_id: webinar.host_id,\n      host_email: webinar.host_email,\n      \n      // FIXED: Alternative hosts with proper handling\n      alternative_hosts: (() => {\n        const altHosts = getSafeString(settings.alternative_hosts, webinar.alternative_hosts, true);\n        if (!altHosts || altHosts === '') return null;\n        const hosts = altHosts.split(',').map(h => h.trim()).filter(h => h.length > 0);\n        return hosts.length > 0 ? hosts : null;\n      })(),\n      \n      // FIXED: Registration information with proper numeric handling\n      registration_required: webinar.registration_required ?? settings.registration_required ?? false,\n      registration_type: getSafeNumeric(settings.registration_type, webinar.registration_type),\n      approval_type: getSafeNumeric(settings.approval_type, webinar.approval_type),\n      \n      // FIXED: Max registrants - this was the main issue!\n      max_registrants: (() => {\n        // Handle the case where registrants_restrict_number is 0 (valid value)\n        const settingsValue = settings.registrants_restrict_number;\n        const webinarValue = webinar.max_registrants;\n        \n        // 0 is a valid value, so we check for null/undefined explicitly\n        if (settingsValue !== undefined && settingsValue !== null) return settingsValue;\n        if (webinarValue !== undefined && webinarValue !== null) return webinarValue;\n        return null;\n      })(),\n      \n      max_attendees: getSafeNumeric(webinar.max_attendees, settings.max_attendees),\n      \n      // URLs\n      join_url: getSafeString(webinar.join_url, settings.join_url),\n      registration_url: getSafeString(webinar.registration_url, settings.registration_url),\n      start_url: getSafeString(webinar.start_url, settings.start_url),\n      \n      // Attendance data\n      total_registrants: getSafeNumeric(webinar.registrants_count, webinar.total_registrants) ?? 0,\n      total_attendees: getSafeNumeric(webinar.total_attendees, webinar.participants_count),\n      total_minutes: getSafeNumeric(webinar.total_minutes, null),\n      avg_attendance_duration: getSafeNumeric(webinar.avg_attendance_duration, null),\n      \n      // FIXED: Password fields with proper handling\n      password: getSafeString(webinar.password, settings.password),\n      h323_password: getSafeString(settings.h323_password, webinar.h323_password),\n      pstn_password: getSafeString(settings.pstn_password, webinar.pstn_password),\n      h323_passcode: getSafeString(settings.h323_passcode, webinar.h323_passcode),\n      encrypted_password: getSafeString(webinar.encrypted_password, null),\n      encrypted_passcode: getSafeString(webinar.encrypted_passcode, null),\n      \n      // FIXED: Agenda with better fallback\n      agenda: getSafeString(webinar.agenda, webinar.description),\n      \n      // JSON fields with proper validation\n      settings: settings && Object.keys(settings).length > 0 ? settings : null,\n      \n      // FIXED: Tracking fields from root webinar object\n      tracking_fields: (() => {\n        const tf = webinar.tracking_fields;\n        if (tf && Array.isArray(tf) && tf.length > 0) {\n          return tf;\n        }\n        // Also check if it's in settings\n        const settingsTf = settings.tracking_fields;\n        if (settingsTf && Array.isArray(settingsTf) && settingsTf.length > 0) {\n          return settingsTf;\n        }\n        return null;\n      })(),\n      \n      // Recurrence data\n      recurrence: (() => {\n        const rec = webinar.recurrence;\n        return (rec && typeof rec === 'object' && Object.keys(rec).length > 0) ? rec : null;\n      })(),\n      \n      // Occurrences data\n      occurrences: (() => {\n        const occ = webinar.occurrences;\n        return (occ && Array.isArray(occ) && occ.length > 0) ? occ : null;\n      })(),\n      \n      // Additional metadata\n      occurrence_id: getSafeString(webinar.occurrence_id, null),\n      creation_source: getSafeString(webinar.creation_source, 'api'),\n      is_simulive: webinar.is_simulive ?? false,\n      record_file_id: getSafeString(webinar.record_file_id, null),\n      transition_to_live: webinar.transition_to_live ?? false,\n      webinar_created_at: webinar.created_at || null,\n      \n      // Sync metadata\n      synced_at: new Date().toISOString(),\n      updated_at: new Date().toISOString(),\n      participant_sync_status: 'pending'\n    };\n    \n    // Clean up undefined values but keep null values\n    Object.keys(webinarData).forEach(key => {\n      if (webinarData[key] === undefined) {\n        delete webinarData[key];\n      }\n    });\n    \n    console.log(`💾 FIXED Enhanced webinar data for ${webinar.id}:`, JSON.stringify(webinarData, null, 2));\n    \n    // Log specific fields we're trying to fix\n    console.log(`🎯 DEBUGGING specific fields for ${webinar.id}:`);\n    console.log(`- max_registrants: ${webinarData.max_registrants} (from settings.registrants_restrict_number: ${settings.registrants_restrict_number})`);\n    console.log(`- registration_type: ${webinarData.registration_type}`);\n    console.log(`- alternative_hosts: ${JSON.stringify(webinarData.alternative_hosts)}`);\n    console.log(`- h323_password: ${webinarData.h323_password}`);\n    console.log(`- tracking_fields: ${JSON.stringify(webinarData.tracking_fields)}`);\n    \n    const { error } = await supabase\n      .from('zoom_webinars')\n      .upsert(webinarData, {\n        onConflict: 'webinar_id,connection_id',\n        returning: 'minimal'\n      });\n\n    if (error) {\n      console.error(`❌ Database error for webinar ${webinar.id}:`, error);\n      return false;\n    }\n    \n    console.log(`✅ Successfully upserted FIXED webinar ${webinar.id}`);\n    return true;\n    \n  } catch (error) {\n    console.error(`💥 Exception storing FIXED webinar ${webinar.id}:`, error);\n    return false;\n  }\n}\n